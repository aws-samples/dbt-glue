{% materialization table, adapter = 'glue'%}
  {% do log("Starting table materialization", info=True) %}

  {% for source_node in graph.sources.values() %}
    {% do log("Checking source: " ~ source_node.schema ~ "." ~ source_node.name, info=True) %}
    {% if not adapter.check_schema_exists(source_node.database, source_node.schema) %}
      {% do exceptions.raise_compiler_error("Source schema '" ~ source_node.schema ~ "' does not exist") %}
    {% endif %}
  {% endfor %}

  {%- set identifier = model.get('alias', model.get('name')) -%}
  {%- if not identifier -%}
    {% do exceptions.raise_compiler_error("Table name not specified: neither 'alias' nor 'name' is defined in the model.") %}
  {%- endif -%}
  {% do log("Using identifier: " ~ identifier, info=True) %}

  {%- set grant_config = config.get('grants') -%}
  {%- set lf_tags_config = config.get('lf_tags_config') -%}
  {%- set lf_grants = config.get('lf_grants') -%}

  {%- set existing_relation_type = none -%}
  {%- if this is not none -%}
    {%- set existing_relation_type = adapter.get_table_type(this) -%}
  {%- endif -%}

  {%- set existing_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}
  {%- if existing_relation is none -%}
    {% set target_relation = glue__make_target_relation(this, config.get('file_format')) %}
  {%- else -%}
    {% set target_relation = existing_relation %}
  {%- endif -%}

  {%- if target_relation is none -%}
    {% do exceptions.raise_compiler_error("Could not create target relation.") %}
  {%- endif -%}

  {{ run_hooks(pre_hooks) }}
  -- setup: if the target relation already exists, drop it
  -- in case if the existing and future table is delta or iceberg, we want to do a
  -- create or replace table instead of dropping, so we don't have the table unavailable
  {% if existing_relation is not none %}
    {% set is_delta = (existing_relation.is_delta and config.get('file_format', validator=validation.any[basestring]) == 'delta') %}
    {% set is_iceberg = (existing_relation.is_iceberg and config.get('file_format', validator=validation.any[basestring]) == 'iceberg') %}
  {% else %}
    {% set is_delta = false %}
    {% set is_iceberg = false %}
    {% set existing_relation_type = 'table' %}
  {% endif %}

  {% if not is_delta and not is_iceberg %}
    {{ drop_relation(target_relation.incorporate(type=existing_relation_type)) }}
  {% endif %}

  -- build model
  {%- call statement('main') -%}
    {{ create_table_as(False, target_relation, compiled_code) }}
  {%- endcall %}
  {% set should_revoke = should_revoke(old_relation, full_refresh_mode=True) %}
  {% do apply_grants(target_relation, grant_config, should_revoke) %}

  {% do persist_docs(target_relation, model) %}

  {% do persist_constraints(target_relation, model) %}
  
  {% if lf_tags_config is not none %}
    {{ adapter.add_lf_tags(target_relation, lf_tags_config) }}
  {% endif %}

  {% if lf_grants is not none %}
    {{ adapter.apply_lf_grants(target_relation, lf_grants) }}
  {% endif %}
  {{ run_hooks(post_hooks) }}

  {{ return({'relations': [target_relation]})}}

{% endmaterialization %}


{% macro py_write_table(compiled_code, target_relation) %}
{{ compiled_code }}
# --- Autogenerated dbt materialization code. --- #
dbt = dbtObj(spark.table)
df = model(dbt, spark)

# make sure pyspark exists in the namepace, for 7.3.x-scala2.12 it does not exist
import pyspark
# make sure pandas exists before using it
try:
  import pandas
  pandas_available = True
except ImportError:
  pandas_available = False

# make sure pyspark.pandas exists before using it
try:
  import pyspark.pandas
  pyspark_pandas_api_available = True
except ImportError:
  pyspark_pandas_api_available = False

# make sure databricks.koalas exists before using it
try:
  import databricks.koalas
  koalas_available = True
except ImportError:
  koalas_available = False

# preferentially convert pandas DataFrames to pandas-on-Spark or Koalas DataFrames first
# since they know how to convert pandas DataFrames better than `spark.createDataFrame(df)`
# and converting from pandas-on-Spark to Spark DataFrame has no overhead
if pyspark_pandas_api_available and pandas_available and isinstance(df, pandas.core.frame.DataFrame):
  df = pyspark.pandas.frame.DataFrame(df)
elif koalas_available and pandas_available and isinstance(df, pandas.core.frame.DataFrame):
  df = databricks.koalas.frame.DataFrame(df)

# convert to pyspark.sql.dataframe.DataFrame
if isinstance(df, pyspark.sql.dataframe.DataFrame):
  pass  # since it is already a Spark DataFrame
elif pyspark_pandas_api_available and isinstance(df, pyspark.pandas.frame.DataFrame):
  df = df.to_spark()
elif koalas_available and isinstance(df, databricks.koalas.frame.DataFrame):
  df = df.to_spark()
elif pandas_available and isinstance(df, pandas.core.frame.DataFrame):
  df = spark.createDataFrame(df)
else:
  msg = f"{type(df)} is not a supported type for dbt Python materialization"
  raise Exception(msg)

df.write.mode("overwrite").format("delta").option("overwriteSchema", "true").saveAsTable("{{ target_relation }}")
{%- endmacro -%}

{%macro py_script_comment()%}
# how to execute python model in notebook
# dbt = dbtObj(spark.table)
# df = model(dbt, spark)
{%endmacro%}
